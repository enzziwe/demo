# Добавляем в индекс один файл
git add file_name
# Добавляем в индекс несколько файлов 
git add file_name_1 file_name_2 file_name_3
# Добавляем в индекс все изменённые файлы 
git add .


$ git status   # Запрашиваем текущее состояние репозитория
# Видим файлы, которые находятся в индексе и подготовлены для коммита
Changes to be committed:
  (use "git restore --staged <file>..." to unstage)
        modified:   index.html
        modified:   styles.css
# Видим неотслеживаемые файлы, которые только попали в проект
Untracked files:
  (use "git add <file>..." to include in what will be committed)
        script.js   # Файл script.js не отслеживается Git
# Видим изменённые файлы репозитория, которые ещё не добавлены в индекс 
Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git restore <file>..." to discard changes in working directory)
        README.md   # Файл README.md был изменён, но не добавлен в индекс

git commit: добавление файлов в репозиторий
Когда все файлы подготовлены к сохранению, их можно перенести из индекса в репозиторий. Для этого нужна команда git commit с опцией -m и сообщением коммита. Сообщение пишется в кавычках и обычно латиницей:

git commit -m "Commit message"
Сообщения обязательны — по ним разработчики ориентируются в проекте. Есть даже специальный документ — «Соглашение о коммитах». В нём разработчики договорились, как правильно добавлять комментарии. Суть в том, чтобы из сообщения коммита было понятно, какие изменения произошли. Вот примеры:

❌ Добавил свой первый коммит.

✅ Исправил баг №ХХХХХ.

❌ Работал над файлом index.html.

✅ Сверстал header для главной страницы.

Если убрать опцию -m, то после нажатия Enter вы попадёте в текстовый редактор. Там вам нужно будет написать сообщение, сохранить его и выйти. А в Vim это нереально ?

Бывает так: вы закоммитили файл и затем снова его изменяете. В этом случае можно делать новый коммит, минуя индекс. Для этого необходима опция -a:

git commit -am "Commit message"
Другая частая ситуация: вы торопились и ошиблись в сообщении коммита. Можно ввести опцию --amend и перезаписать сообщение последнего коммита:

git commit --amend -m "New commit message"

# Откатываемся и переводим последующие коммиты в индекс
git reset --soft commit_hash

# Откатываемся и переводим последующие коммиты в неотслеживаемую зону
git reset --mixed commit_hash

# Откатываемся и удаляем все последующие коммиты
git reset --hard commit_hash

git branch <branch_name>: создание новой ветки
После первого коммита Git автоматически создаёт первую ветку. Обычно в ней хранят стабильную версию проекта для пользователей продукта. Под остальные задачи разработчики создают отдельные ветки с помощью команды git branch:

git branch branch_name
По названию ветки должно быть понятно, что в ней происходит. Например, если в названии упоминается слово bugfix, то ветка предназначена для исправления ошибок. Слово feature указывает на разработку какой-то функции. А вот случайное название test10.24 не значит ничего, и таких названий лучше избегать.

Ветку с неудачным названием можно переименовать:

git branch -m old_branch_name new_branch_name

# old_branch_name — старое имя ветки 
# new_branch_name — новое имя ветки
git branch: просмотр веток
Команда git branch позволяет получить список всех доступных веток в проекте. Также она проставляет символ звёздочки слева от текущей активной ветки:

# Запрашиваем список всех доступных веток 
git branch

# Результат вывода
  bugfix/fix-bug
  * maine
  feature/new-feature
git checkout: переключение между ветками
Команда git checkout позволяет переключиться с одной ветки на другую:

git checkout branch_name
Также можно одной командой создать новую ветку и сразу в неё перейти:

git checkout -b branch_name
У команды git checkout есть более современная альтернатива:

git switch branch_name
Команда git switch безопасней и больше подходит новичкам. Перед каждым переключением она автоматически проверяет рабочую директорию и не срабатывает, если переход на выбранную ветку может привести к потере данных.

git push: отправка изменений в удалённый репозиторий
Команда git push загружает изменения из локального репозитория в удалённый.

Во время первой загрузки нужно использовать команду с опцией -u. Это свяжет локальную и удалённую ветки и синхронизирует их для последующих операций. Для второй и всех последующих загрузок опция -u для связанных веток не понадобится.

# Команда для первой загрузки изменений в удалённый репозиторий: текущая ветка будет связана с веткой main в удалённом репозитории origin 
git push -u origin main

# Команда для второй и последующих загрузок изменений в удалённый репозиторий 
git push
git pull: получение изменений из удалённого репозитория
Команда git pull скачивает изменения из удалённого репозитория в локальный.

# Скачиваем изменения из удалённого репозитория и добавляем их в локальную ветку
git pull